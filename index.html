<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Python Program Library</title>
<style>
    body {
        font-family: Arial, sans-serif;
        background: #f0f2f5;
        margin: 0;
        padding: 20px;
    }
    h1 {
        text-align: center;
        color: #333;
    }
    .container {
        display: grid;
        grid-template-columns: repeat(auto-fill,minmax(300px,1fr));
        gap: 20px;
        margin-top: 30px;
    }
    .card {
        background: white;
        border-radius: 10px;
        box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        padding: 20px;
        transition: transform 0.2s, box-shadow 0.2s;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
    }
    .card:hover {
        transform: translateY(-5px);
        box-shadow: 0 8px 25px rgba(26,115,232,0.2);
    }
    .program-name {
        font-weight: bold;
        color: #1a73e8;
        margin-bottom: 10px;
    }
    .description {
        font-size: 0.9rem;
        color: #555;
        margin-bottom: 15px;
    }
    .copy-btn {
        padding: 10px;
        background: #1a73e8;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background 0.2s;
        align-self: flex-end;
        font-weight: 600;
    }
    .copy-btn:hover {
        background: #155ab6;
    }
</style>
</head>
<body>

<h1>Python Program Library</h1>
<div class="container" id="program-container">
    <!-- Cards will be injected here by JavaScript -->
</div>

<script>
// List of programs with name, description, and code
const programs = [
    {
        name: "A1: Library Borrow Management",
        description: "Compute average books, max/min borrowed, zero borrowers, and mode.",
        code: `# Library Borrow Management System
members = {"Amit":3,"Riya":5,"Omkar":0,"Nayan":2,"Sana":5,"Tejas":1}
average_borrow = sum(members.values())/len(members)
print("Average number of books borrowed:",average_borrow)
max_borrow = max(members.values())
min_borrow = min(members.values())
print("Highest number of books borrowed:",max_borrow)
print("Lowest number of books borrowed:",min_borrow)
no_borrow_count = sum(1 for b in members.values() if b==0)
print("Number of members who borrowed no books:",no_borrow_count)
from collections import Counter
mode_borrow = Counter(members.values()).most_common(1)[0][0]
print("Most frequently borrowed book count (mode):",mode_borrow)`
    },
    {
        name: "A2: Search Algorithms",
        description: "Linear and Binary search for customer account IDs.",
        code: `# Linear and Binary Search Example
def linear_search(arr,key):
    for i,v in enumerate(arr):
        if v==key:
            return i
    return -1

def binary_search(arr,key):
    arr.sort()
    low,high=0,len(arr)-1
    while low<=high:
        mid=(low+high)//2
        if arr[mid]==key:
            return mid
        elif arr[mid]<key:
            low=mid+1
        else:
            high=mid-1
    return -1

customers = [23,45,12,67,34]
key = 34
print("Linear Search index:",linear_search(customers,key))
print("Binary Search index:",binary_search(customers,key))`
    },
    {
        name: "A3: Sort Salaries",
        description: "Selection sort and Bubble sort for employee salaries.",
        code: `# Selection Sort
def selection_sort(arr):
    for i in range(len(arr)):
        min_idx=i
        for j in range(i+1,len(arr)):
            if arr[j]<arr[min_idx]:
                min_idx=j
        arr[i],arr[min_idx]=arr[min_idx],arr[i]
    return arr

# Bubble Sort
def bubble_sort(arr):
    n=len(arr)
    for i in range(n):
        for j in range(0,n-i-1):
            if arr[j]>arr[j+1]:
                arr[j],arr[j+1]=arr[j+1],arr[j]
    return arr

salaries=[50000,70000,30000,90000,60000]
print("Selection Sort:",selection_sort(salaries.copy()))
print("Bubble Sort:",bubble_sort(salaries.copy()))`
    },
    {
        name: "B1: Undo/Redo System",
        description: "Real-time undo/redo for a text editor using stack.",
        code: `undo_stack=[]
redo_stack=[]
document=""
def make_change(new_text):
    global document
    undo_stack.append(document)
    redo_stack.clear()
    document=new_text
    print("Change made.")
def undo():
    global document
    if undo_stack:
        redo_stack.append(document)
        document=undo_stack.pop()
        print("Undo performed.")
    else: print("Nothing to undo.")
def redo():
    global document
    if redo_stack:
        undo_stack.append(document)
        document=redo_stack.pop()
        print("Redo performed.")
    else: print("Nothing to redo.")
def display(): print("Current Document:",document)
make_change("Hello")
make_change("Hello World")
display()
undo()
display()
redo()
display()`
    },
    {
        name: "B2: Event Processing System",
        description: "Queue-based system to add, process, display, cancel events.",
        code: `from collections import deque
event_queue=deque()
def add_event(event):
    event_queue.append(event)
    print(f"Event '{event}' added.")
def process_event():
    if event_queue: print("Processing:",event_queue.popleft())
    else: print("No events.")
def display_events():
    print("Pending Events:",list(event_queue))
def cancel_event(event):
    try: event_queue.remove(event); print(f"Event '{event}' canceled.")
    except: print("Event not found.")
add_event("Login")
add_event("Upload")
display_events()
process_event()
cancel_event("Upload")
display_events()`
    },
    {
        name: "B4: Student Record Management",
        description: "Singly linked list storing student roll no, name, marks; add/delete/update/search/sort.",
        code: `class Node:
    def __init__(self, roll_no, name, marks):
        self.roll_no = roll_no
        self.name = name
        self.marks = marks
        self.next = None

class StudentLinkedList:
    def __init__(self):
        self.head = None

    def add_student(self, r, n, m):
        new = Node(r, n, m)
        if not self.head:
            self.head = new
        else:
            temp = self.head
            while temp.next:
                temp = temp.next
            temp.next = new
        print("Student added!")

    def display_students(self):
        temp = self.head
        if not temp:
            print("No records")
            return
        while temp:
            print(f"Roll: {temp.roll_no}, Name: {temp.name}, Marks: {temp.marks}")
            temp = temp.next

# Example usage
sll = StudentLinkedList()
sll.add_student(1, "Omkar", 85)
sll.add_student(2, "Nayan", 78)
sll.display_students()`
    },
    {
        name: "C1: Hash Table Chaining",
        description: "Hash table size 10, division method, collision resolved by chaining.",
        code: `class HashTable:
    def __init__(self,size=10): self.size=size; self.table=[[] for _ in range(size)]
    def hash_function(self,key): return key%self.size
    def insert(self,key,value):
        idx=self.hash_function(key)
        for pair in self.table[idx]:
            if pair[0]==key: pair[1]=value; return
        self.table[idx].append([key,value])
    def search(self,key):
        idx=self.hash_function(key)
        for pair in self.table[idx]:
            if pair[0]==key: return pair[1]
        return None
    def delete(self,key):
        idx=self.hash_function(key)
        for pair in self.table[idx]:
            if pair[0]==key: self.table[idx].remove(pair); return
ht=HashTable()
ht.insert(10,'A'); ht.insert(20,'B')
print(ht.search(10))
ht.delete(10); print(ht.search(10))`
    },
    {
        name: "C2: Hash Table Linear Probing",
        description: "Hash table size 10, division method, collisions resolved by linear probing.",
        code: `class LinearProbingHashTable:
    def __init__(self,size=10): self.size=size; self.table=[None]*size
    def hash_function(self,key): return key%self.size
    def insert(self,key):
        idx=self.hash_function(key)
        start=idx
        while self.table[idx] not in (None,"DELETED"):
            idx=(idx+1)%self.size
            if idx==start: return
        self.table[idx]=key
    def search(self,key):
        idx=self.hash_function(key)
        start=idx
        while self.table[idx] is not None:
            if self.table[idx]==key: return idx
            idx=(idx+1)%self.size
            if idx==start: break
        return None
    def delete(self,key):
        idx=self.search(key)
        if idx is not None: self.table[idx]="DELETED"
ht=LinearProbingHashTable()
ht.insert(10); ht.insert(20)
print(ht.search(10))
ht.delete(10); print(ht.search(10))`
    },
    {
        name: "D1: Graph BFS & DFS",
        description: "Traverse city locations using BFS (Adjacency List) and DFS (Adjacency Matrix).",
        code: `from collections import deque
locations=['A','B','C','D','E']
adj_matrix=[[0,1,1,0,0],[1,0,0,1,0],[1,0,0,1,1],[0,1,1,0,1],[0,0,1,1,0]]
def dfs(start,visited):
    idx=locations.index(start); print(start,end=" "); visited[idx]=True
    for i in range(len(locations)):
        if adj_matrix[idx][i]==1 and not visited[i]: dfs(locations[i],visited)
visited=[False]*len(locations)
print("DFS sequence:"); dfs('A',visited)
adj_list={'A':['B','C'],'B':['A','D'],'C':['A','D','E'],'D':['B','C','E'],'E':['C','D']}
def bfs(start):
    visited=set(); queue=deque([start]); visited.add(start)
    print("\\nBFS sequence:",end=" ")
    while queue:
        node=queue.popleft(); print(node,end=" ")
        for neighbor in adj_list[node]:
            if neighbor not in visited: visited.add(neighbor); queue.append(neighbor)
bfs('A')`
    },
    {
        name: "BST Operations",
        description: "Binary Search Tree with insertion, deletion, search, and inorder display.",
        code: `class Node:
    def __init__(self,key): self.key=key; self.left=None; self.right=None
class BST:
    def __init__(self): self.root=None
    def insert(self,key):
        self.root=self._insert(self.root,key)
    def _insert(self,root,key):
        if root is None: return Node(key)
        if key<root.key: root.left=self._insert(root.left,key)
        elif key>root.key: root.right=self._insert(root.right,key)
        return root
    def search(self,key):
        return self._search(self.root,key)
    def _search(self,root,key):
        if root is None: return None
        if root.key==key: return root
        if key<root.key: return self._search(root.left,key)
        return self._search(root.right,key)
    def inorder(self):
        self._inorder(self.root); print()
    def _inorder(self,root):
        if root: self._inorder(root.left); print(root.key,end=" "); self._inorder(root.right)
bst=BST()
bst.insert(50); bst.insert(30); bst.insert(70)
bst.inorder(); print(bst.search(70).key)`
    }
];

// Generate cards dynamically
const container = document.getElementById("program-container");
programs.forEach(prog=>{
    const card=document.createElement("div");
    card.className="card";
    card.innerHTML=`
        <div class="program-name">${prog.name}</div>
        <div class="description">${prog.description}</div>
        <button class="copy-btn">Copy Code</button>
    `;
    const btn = card.querySelector(".copy-btn");
    btn.addEventListener("click",()=>{
        navigator.clipboard.writeText(prog.code).then(()=>{
            btn.innerText="Copied!";
            setTimeout(()=>btn.innerText="Copy Code",1000);
        });
    });
    container.appendChild(card);
});
</script>

</body>
</html>
